<!DOCTYPE html>
<html>
<head>
  <title>OpenGeometry</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      margin: 0;
    }
  </style>
</head>
<body>
  <div id="app"
    style="width: 100vw; height: 100vh;"
  ></div>

  <script type="module">
    import {
      OpenGeometry,
      BasePoly,
      BaseCircle,
      CirclePoly,
      Vector3D,
      SpotLabel,
      Rectangle,
      RectanglePoly
    } from './../index.ts';
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
    import Stats from 'three/examples/jsm/libs/stats.module.js';

    let scene, camera, renderer;
    let openGeometry;
    let stats = new Stats();

    // Circle and Cylinder Dimensions
    const circleRadius = 2.42;
    const circleSegments = 16;
    const circleStartAngle = 0;
    const circleEndAngle = Math.PI * 2; 
    const circleExtrude = 1.8;

    async function init(){
      const app = document.getElementById('app');

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      renderer.setSize(app.clientWidth, app.clientHeight);
      app.appendChild(renderer.domElement);

      openGeometry = new OpenGeometry(app, scene, camera);
      await openGeometry.setup();

      // grid
      const gridHelper = new THREE.GridHelper(200, 200);
      // scene.add(gridHelper);

      scene.background = new THREE.Color(0xf0f0f0);

      camera.position.z = 20;
      camera.position.y = 15;
    
      // ambient light
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 100, 100).normalize();
      scene.add(directionalLight);
      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight2.position.set(-100, 70, -100).normalize();
      scene.add(directionalLight2);

      // controls
      const controls = new OrbitControls(
        camera,
        openGeometry.labelRenderer.domElement
      );
      controls.update();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      const circleData = {
        radius: circleRadius,
        segments: circleSegments,
        position: new Vector3D(-12, 0, -4),
        startAngle: circleStartAngle,
        endAngle: circleEndAngle,
      }

      // Create Base Circle
      const ogCircle = new BaseCircle(circleData);
      scene.add(ogCircle);

      // Create Circle Poly from Base Circle
      const ogCirclePoly = new CirclePoly(ogCircle);
      scene.add(ogCirclePoly);
      ogCirclePoly.extrude(circleExtrude);

      // Lego 2x3
      const circleData2 = {
        radius: circleRadius,
        segments: circleSegments,
        position: new Vector3D(-4, 0, -4),
        startAngle: circleStartAngle,
        endAngle: circleEndAngle,
      }
      const ogCircle2 = new BaseCircle(circleData2);
      scene.add(ogCircle2);
      const ogCirclePoly2 = new CirclePoly(ogCircle2);
      scene.add(ogCirclePoly2);
      ogCirclePoly2.extrude(circleExtrude);

      const circleData3 = {
        radius: circleRadius,
        segments: circleSegments,
        position: new Vector3D(4, 0, -4),
        startAngle: circleStartAngle,
        endAngle: circleEndAngle,
      }
      const ogCircle3 = new BaseCircle(circleData3);
      scene.add(ogCircle3);
      const ogCirclePoly3 = new CirclePoly(ogCircle3);
      scene.add(ogCirclePoly3);
      ogCirclePoly3.extrude(circleExtrude);

      const circleData4 = {
        radius: circleRadius,
        segments: circleSegments,
        position: new Vector3D(12, 0, -4),
        startAngle: circleStartAngle,
        endAngle: circleEndAngle,
      }
      const ogCircle4 = new BaseCircle(circleData4);
      scene.add(ogCircle4);
      const ogCirclePoly4 = new CirclePoly(ogCircle4);
      scene.add(ogCirclePoly4);
      ogCirclePoly4.extrude(circleExtrude);

      // Below Row
      const circleData5 = {
        radius: circleRadius,
        segments: circleSegments,
        position: new Vector3D(-12, 0, 4),
        startAngle: circleStartAngle,
        endAngle: circleEndAngle,
      }
      const ogCircle5 = new BaseCircle(circleData5);
      scene.add(ogCircle5);
      const ogCirclePoly5 = new CirclePoly(ogCircle5);
      scene.add(ogCirclePoly5);
      ogCirclePoly5.extrude(circleExtrude);

      const circleData6 = {
        radius: circleRadius,
        segments: circleSegments,
        position: new Vector3D(-4, 0, 4),
        startAngle: circleStartAngle,
        endAngle: circleEndAngle,
      }
      const ogCircle6 = new BaseCircle(circleData6);
      scene.add(ogCircle6);
      const ogCirclePoly6 = new CirclePoly(ogCircle6);
      scene.add(ogCirclePoly6);
      ogCirclePoly6.extrude(circleExtrude);

      const circleData7 = {
        radius: circleRadius,
        segments: circleSegments,
        position: new Vector3D(4, 0, 4),
        startAngle: circleStartAngle,
        endAngle: circleEndAngle,
      }
      const ogCircle7 = new BaseCircle(circleData7);
      scene.add(ogCircle7);
      const ogCirclePoly7 = new CirclePoly(ogCircle7);
      scene.add(ogCirclePoly7);
      ogCirclePoly7.extrude(circleExtrude);

      const circleData8 = {
        radius: circleRadius,
        segments: circleSegments,
        position: new Vector3D(12, 0, 4),
        startAngle: circleStartAngle,
        endAngle: circleEndAngle,
      }
      const ogCircle8 = new BaseCircle(circleData8);
      scene.add(ogCircle8);
      const ogCirclePoly8 = new CirclePoly(ogCircle8);
      scene.add(ogCirclePoly8);
      ogCirclePoly8.extrude(circleExtrude);

      // Base
      const rectangleData = {
        center: new Vector3D(0, 0, 0),
        width: 31.8,
        breadth: 15.8
      }

      // Create Base Rectangle
      const ogRectangle = new Rectangle(rectangleData);
      scene.add(ogRectangle);

      const ogRectanglePoly = new RectanglePoly(ogRectangle);
      scene.add(ogRectanglePoly);
      ogRectanglePoly.extrude(-9.60);

      // Extrude By 3
      // ogRectangle.extrude(1);

      const outlineGroup = new THREE.Group();
      const sideOutline2 = ogCirclePoly2.getOutline('front');
      outlineGroup.add(sideOutline2);
      const sideOutline3 = ogCirclePoly3.getOutline('front');
      outlineGroup.add(sideOutline3);
      const sideOutline4 = ogCirclePoly4.getOutline('front');
      outlineGroup.add(sideOutline4);
      const sideOutline5 = ogCirclePoly5.getOutline('front');
      outlineGroup.add(sideOutline5);
      const sideOutline6 = ogCirclePoly6.getOutline('front');
      outlineGroup.add(sideOutline6);
      const sideOutline7 = ogCirclePoly7.getOutline('front');
      outlineGroup.add(sideOutline7);
      const sideOutline8 = ogCirclePoly8.getOutline('front');
      outlineGroup.add(sideOutline8);

      const sideOutlineRect = ogRectanglePoly.getOutline('front');
      outlineGroup.add(sideOutlineRect);

      scene.add(outlineGroup);
      outlineGroup.position.set(10, 0, 0);

      // Front
      const frontOutGroup = new THREE.Group();
      const frontOutline = ogCirclePoly.getOutline('side');
      frontOutGroup.add(frontOutline);
      const frontOutline2 = ogCirclePoly2.getOutline('side');
      frontOutGroup.add(frontOutline2);
      const frontOutline3 = ogCirclePoly3.getOutline('side');
      frontOutGroup.add(frontOutline3);
      const frontOutline4 = ogCirclePoly4.getOutline('side');
      frontOutGroup.add(frontOutline4);
      const frontOutline5 = ogCirclePoly5.getOutline('side');
      frontOutGroup.add(frontOutline5);
      const frontOutline6 = ogCirclePoly6.getOutline('side');
      frontOutGroup.add(frontOutline6);
      const frontOutline7 = ogCirclePoly7.getOutline('side');
      frontOutGroup.add(frontOutline7);
      const frontOutline8 = ogCirclePoly8.getOutline('side');
      frontOutGroup.add(frontOutline8);

      const frontOutlineRect = ogRectanglePoly.getOutline('side');
      frontOutGroup.add(frontOutlineRect);

      scene.add(frontOutGroup);
      frontOutGroup.position.set(-30, 0, 0);

      // Top
      const topOutGroup = new THREE.Group();
      const topOutline = ogCirclePoly.getOutline('top');
      topOutGroup.add(topOutline);
      const topOutline2 = ogCirclePoly2.getOutline('top');
      topOutGroup.add(topOutline2);
      const topOutline3 = ogCirclePoly3.getOutline('top');
      topOutGroup.add(topOutline3);
      const topOutline4 = ogCirclePoly4.getOutline('top');
      topOutGroup.add(topOutline4);
      const topOutline5 = ogCirclePoly5.getOutline('top');
      topOutGroup.add(topOutline5);
      const topOutline6 = ogCirclePoly6.getOutline('top');
      topOutGroup.add(topOutline6);
      const topOutline7 = ogCirclePoly7.getOutline('top');
      topOutGroup.add(topOutline7);
      const topOutline8 = ogCirclePoly8.getOutline('top');
      topOutGroup.add(topOutline8);

      const topOutlineRect = ogRectanglePoly.getOutline('top');
      topOutGroup.add(topOutlineRect);
      scene.add(topOutGroup);
      topOutGroup.position.set(-20, 0, 0);

      initGUI();
      animate();

      // center sphere
      const centerSphereGeometry = new THREE.SphereGeometry(0.2, 32, 32);
      const centerSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: false });
      const centerSphere = new THREE.Mesh(centerSphereGeometry, centerSphereMaterial);
      centerSphere.position.set(0, 0, 0);
      scene.add(centerSphere);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
      openGeometry.update(scene, camera);
      stats.update();
    }

    init();

    function initGUI() {
      
    }

    stats.showPanel(0); // 0: fps, 1: ms, 2: memory
    document.body.appendChild(stats.dom);
  </script>
</body>
</html>
